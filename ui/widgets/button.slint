import { Body, ExtendedTouchArea } from "../components/components.slint";
import { Brushes, Palette, Settings, Icons } from "../styling/styling.slint";

component ButtonBase inherits ExtendedTouchArea {
    in property <string> text;
    in property <image> leading-icon;
    in property <image> trailing-icon;
    in property <brush> content-color;

    horizontal-stretch: 0;
    vertical-stretch: 0;
    border-radius: 16px;
    min-height: max(32px, i-layout.min-height);
    min-width: self.min-height;
    padding-left: 16px;
    padding-right: 16px;

    i-layout := HorizontalLayout {
        padding-left: root.padding-left;
        padding-right: root.padding-right;
        spacing: 4px;
        alignment: center;

        if (leading-icon.width > 0 && leading-icon.height > 0) : Image {
            image-fit: contain;
            y: (parent.height - self.height) / 2;
            source: root.leading-icon;
            colorize: root.content-color;
            width: 16px;
            height: self.width;
        }

        if (root.text != "") : Body {
            horizontal-alignment: center;
            vertical-alignment: center;
            text: root.text;
            color: root.content-color;
        }

        if (trailing-icon.width > 0 && trailing-icon.height > 0) : Image {
            image-fit: contain;
            y: (parent.height - self.height) / 2;
            source: root.trailing-icon;
            colorize: root.content-color;
            width: 16px;
            height: self.width;
        }
    }
}

export component PrimaryButton {
    callback clicked <=> i-button-base.clicked;

    in property <bool> enabled <=> i-button-base.enabled;
    out property <bool> has-focus <=> i-button-base.has-focus;
    out property <bool> pressed <=> i-button-base.pressed;
    in property <string> text <=> i-button-base.text;
    in property <bool> destructive;

    min-height: i-button-base.min-height;
    horizontal-stretch: i-button-base.horizontal-stretch;
    vertical-stretch: i-button-base.vertical-stretch;
    forward-focus: i-button-base;
    accessible-role: button;
    accessible-label <=> i-button-base.text;

    i-button-base := ButtonBase {
        background: root.destructive ? Brushes.destructive-color : Brushes.accent-color;
        content-color: Brushes.on-accent-color;
    }
}

export component StandardButton {
    callback clicked <=> i-button-base.clicked;

    in property <bool> enabled <=> i-button-base.enabled;
    out property <bool> has-focus <=> i-button-base.has-focus;
    out property <bool> pressed <=> i-button-base.pressed;
    in property <string> text <=> i-button-base.text;

    horizontal-stretch: i-button-base.horizontal-stretch;
    vertical-stretch: i-button-base.vertical-stretch;
    forward-focus: i-button-base;
    accessible-role: button;
    accessible-label <=> i-button-base.text;
    min-width: i-button-base.min-width;
    min-height: i-button-base.min-height;

    i-button-base := ButtonBase {
        // FIXME: correct color mapping
        background: Settings.dark-color-scheme ? #AEAEAE40 : #5D5D5D40;
        content-color: Palette.neutral-9;
    }
}

export component TextButton {
    callback clicked <=> i-button-base.clicked;

    in property <bool> enabled <=> i-button-base.enabled;
    out property <bool> has-focus <=> i-button-base.has-focus;
    out property <bool> pressed <=> i-button-base.pressed;
    in property <string> text <=> i-button-base.text;
    in property <image> icon <=> i-button-base.trailing-icon;
    in property <bool> destructive;

    horizontal-stretch: i-button-base.horizontal-stretch;
    vertical-stretch: i-button-base.vertical-stretch;
    forward-focus: i-button-base;
    accessible-role: button;
    accessible-label <=> i-button-base.text;
    min-width: i-button-base.min-width;
    min-height: i-button-base.min-height;

    i-button-base := ButtonBase {
        // FIXME: correct color mapping
        content-color: root.destructive ? Brushes.destructive-color : Brushes.accent-text-color;
    }
}

export component IconButton {
    callback clicked();
    callback toggled(bool /* checked */);

    in property <bool> enabled <=> i-button-base.enabled;
    out property <bool> has-focus <=> i-button-base.has-focus;
    out property <bool> pressed <=> i-button-base.pressed;
    in property <string> text <=> i-button-base.text;
    in property <image> leading-icon <=> i-button-base.leading-icon;
    in property <image> trailing-icon <=> i-button-base.trailing-icon;
    in-out property <bool> checked <=> i-button-base.selected;
    in property <bool> checkable;
    in property <bool> primary;

    horizontal-stretch: i-button-base.horizontal-stretch;
    vertical-stretch: i-button-base.vertical-stretch;
    forward-focus: i-button-base;
    accessible-role: button;
    accessible-label <=> i-button-base.text;
    min-width: i-button-base.min-width;
    min-height: i-button-base.min-height;

    i-button-base := ButtonBase {
        // FIXME: correct color mapping
        content-color: root.checked || root.primary ? Brushes.accent-text-color : Brushes.on-primary-container-color;
        padding-left: 8px;
        padding-right: 8px;

        clicked => {
            if (root.checkable) {
                root.checked = !root.checked;
                root.toggled(root.checked);
            }

            root.clicked();
        }
    }
}